pragma language_version >= 0.14.0;

import CompactStandardLibrary;

export { CoinInfo };

export ledger counter: Counter;
export ledger nonce: Bytes<32>;
export ledger tvl_token: Uint<64>;

export ledger reward: QualifiedCoinInfo; 
export ledger coin_received: QualifiedCoinInfo;  
export ledger tvl_dust: Uint<64>;
export sealed ledger owner_public_key: Maybe<ZswapCoinPublicKey>;

constructor(initNonce: Bytes<32>) {
  nonce = initNonce;
  owner_public_key = some<ZswapCoinPublicKey>(own_public_key());
}

export circuit mint(coin: CoinInfo): [] {
  receive(coin);
  assert coin.value == 200 "requires 200 t-dust";
  assert coin.color == native_token() "Invalid coin provided";  
  if (tvl_dust == 0) {
        reward.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
        tvl_dust = tvl_dust + coin.value as Uint<64>;
  } else {  
        coin_received.write_coin(coin, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));      
        const coin_sum = merge_coin(reward, coin_received);
        reward.write_coin(coin_sum, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
        tvl_dust = tvl_dust + coin.value as Uint<64>;
  }    

  counter.increment(1);
  const newNonce = evolve_nonce(counter, nonce);
  const amount = 1000;
  tvl_token = tvl_token + amount as Uint<64>;
  mint_token(pad(32, "test_coin"), amount, newNonce, left<ZswapCoinPublicKey, ContractAddress>(own_public_key()));
  nonce = newNonce;  
}

export circuit owner_withdraw(): [] {    
  const send_result =  send(reward, left<ZswapCoinPublicKey, ContractAddress>(owner_public_key.value), reward.value); 
   
  tvl_dust = tvl_dust - reward.value as Uint<64>; 
  if (tvl_dust != 0) {
      reward.write_coin(send_result.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
  }           
   
}
